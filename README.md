# Современные плюсцы))
## Фичи новых стандартов
### Фичи языка
- Ослабленные требования к `constexpr`, позволящие писать более сложный код. Одна из его фишек — это более строгая проверка и запрет на UB в теле функции. Константы полеезнее также делать как `constexpr`, а не дефайнами, ибо у компилятора будет  информация о типах и он сможет предупредить о неожиданных переполнениях, например
- Больше трейтов в стандартной библиотеке, позволяющих вместо своих непроверенных костылей использовать стандартные провереннные средства и оставлять код более читаемым
- `constexpr` шаблонные переменные, позволяющие вместо `typename std::enable_if<std::is_same<T1, T2>::value, U>::type` просто `std::enable_if_t<std::is_same_v<T1, T2>, U>`, что опять же увеличивает читаемость кода, освобождая его от служебных нагромождений
- Структурное связывание, позволяющее давать осмысленные имена при пробеге по мапам, вместо пары с ничего не говорящими `.first` и `.second`
- `constexpr if`, облегчающий написание шаблонных функций со SFINAE — делающий их более читабельными вместо копипасты общих участков функции в две почти идентичные (пример в simple_job.h)

### Фичи стандартной библиотеки
#### Это же не часть языка, можно взять откуда-нибудь!
Действительно, возможности стандартной библиотеки, как правило, реализуемы в рамках старых стандартов,
однако зависеть от буста мы всё ещё боимся, а реализация своими руками связана с рядом проблем:
- Зачастую даже для достаточно тупых обёрток (вроде `string_view`) приходится писать много бойлерплейта,
из-за чего усилий на написание уходит не то чтобы пренебрежимо мало
- Когда хочешь воспользоваться фичей, которую, как выясняется, в наших велосипедах пока не реализовали,
приходится идти и реализовывать её, выпадая из контекста, что пагубно влияет на продуктивность
- Иногда случаются баги, притом сильно чаще, чем в коде, которые постоянно используется тысячами людей
#### Что за фичи такие
- `std::chrono` — работа с временем
- Алгоритмы вроде `count_if`
#### Чем полезно их наличие / вредно отсутствие
#### Чем можно заменить при использовании старых стандартов языка
## Фичи современных компиляторов
- Продвинутые оптимизаторы
### Чем мешает отсутствие возможности компилировать ими на проде
